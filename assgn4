1.) exit
	li $v0, 10
	syscall

2.) jumplabel main_class_Main()
	# TODO This has to be done at the end and separately from other jumplabels.

3.) TAC.emit(p0['place'], p1['place'],'', '=') -> register1 = register2
	lw $regfree1, p1_offset($sp)          
	move $regfree2, $regfree1
	sw $regfree2, p0_offset($sp)

3.1) TAC.emit(p0['place'],0,'', '=') -> register1 = register2
	li $regfree1, 0          
	sw $regfree1, p0_offset($sp)

3.2) TAC.emit(p0['place'],1,'', '=') -> register1 = register2
	li $regfree1, 1          
	sw $regfree1, p0_offset($sp)

4.) TAC.emit(p1['place'],0,lineno,'cond_goto')  -> cond_jump(p[3]) to 'line'(p[2]) on register(p[0]) == 0(p[1])
        li $regfree1, 0
	lw $regfree2, p1_offset($sp)
	beq $regfree1,$regfree2,L_lineno

4.1) TAC.emit(p1['place'],1,lineno,'cond_goto')  -> cond_jump(p[3]) to 'line'(p[2]) on register(p[0]) == 0(p[1])
        li $regfree1, 1
	lw $regfree2, p1_offset($sp)
	beq $regfree1,$regfree2,L_lineno

4.2) TAC.emit(p1['place'],p2['place'],lineno,'cond_goto')  -> cond_jump(p[3]) to 'line'(p[2]) on register(p[0]) == 0(p[1])
	lw $regfree1, p1_offset($sp)
	lw $regfree2, p2_offset($sp)
	beq $regfree1,$regfree2,L_lineno


5.) TAC.emit('','',lineno,'goto') -> go_to(p[0]) line(p[2])
        b L_lineno

6.) register = 1/0
	Done in 4.1 and 4.2

7.) TAC.emit(p0['place'], p1['place'], p3['place'], '|') -> register0 = register1 bit_or register2 (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	or $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
	

8.) TAC.emit(p0['place'], p1['place'], p3['place'], '^') -> register = register bit_xor register (only for int)
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	xor $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

9.) TAC.emit(p0['place'], p1['place'], p3['place'], '&') -> register = register bit_and register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	and $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)	
        
10.) TAC.emit(p0['place'], p1['place'], p3['place'], '==') -> register = register equal register
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	seq $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)	        
	
11.) TAC.emit(p0['place'], p1['place'], p3['place'], '!=') -> register = register not_equal register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sne $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)	

12.) TAC.emit(p0['place'], p1['place'], p3['place'], '<') -> register0 = register1 less_than register2
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	slt $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)        
	
13.) TAC.emit(p0['place'], p1['place'], p3['place'], '>') -> register = register greater_than register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sgt $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)      

14.) TAC.emit(p0['place'], p1['place'], p3['place'], '<=') -> register = register less_than_equal register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sle $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

15.) TAC.emit(p0['place'], p1['place'], p3['place'], '>=') -> register = register greater_than_equal register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sge $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

16.) TAC.emit(p0['place'], p1['place'], p3['place'], '<<') ->register = register lshift register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sllv $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
        
17.) TAC.emit(p0['place'], p1['place'], p3['place'], '>>') ->register = register rshift register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	srlv $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

18.) TAC.emit(p0['place'], p1['place'], p3['place'], '+') ->register = register add register
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	add $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
   
19.) TAC.emit(p0['place'], p1['place'], p3['place'], '-') ->register = register1 sub register2
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sub $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
   
20.) TAC.emit(p0['place'], p1['place'], p3['place'], '*') -> register0 = register1 mult register2
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	mult $regfree1, $regfree2
	mflo $regfree3	
	sw $regfree3, p0_offset($sp)        
	
21.) TAC.emit(p0['place'], p1['place'], p3['place'], '/') -> register0 = register1 div register2
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	div $regfree1, $regfree2
	mflo $regfree3	
	sw $regfree3, p0_offset($sp)        

22.) TAC.emit(p0['place'], p1['place'], p3['place'], '%') -> register = register mod register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	div $regfree1, $regfree2
	mfhi $regfree3	
	sw $regfree3, p0_offset($sp)        
        
23.) TAC.emit(p0['place'], p1['place'],'', '~') -> register = bit_complement register (int and double)
	li $regfree1, -1        
	lw $regfree2, p1_offset($sp)
	xor $regfree3, $regfree2, $regfree1
	sw $regfree3, p0_offset($sp)	
	
24.) TAC.emit(p0['place'], p1['place'],'', '-unary') -> register1 = negative register2 (int and double)
	lw $regfree1, p1_offset($sp)        
	neg $regfree2,$regfree1
	sw $regfree2, p0_offset($sp)

25.) TAC.emit(p0['place'], p1['place'],'', '!') -> register = bit_not register (only bool)
        li $regfree1, 1
	lw $regfree2, p1_offset($sp)
	xor $regfree3, $regfree2, $regfree1
	sw $regfree3, p0_offset($sp)	
	
26.) TAC.emit(p0['place'],num,'','=dec') -> register = value
	li $regfree1, num
	sw $regree1, p0_offset($sp)

27.) TAC.emit(p[0]['place'],var['place'],'','=_derefload') -> p0 takes value from var from self object
	lw $regfree1, 0($sp)
	lw $regfree2, var_offset($regfree1)
	sw $regfree2, p0_offset($sp)
	
	var_offset is determined from class layout of self object
	We assume object is at 0($sp), it will actually be at 4($sp), return address will be at 0($sp)

28.) TAC.emit(p[0]['place'],p[1]['var']['place']+'['+p[1]['exp']['place']+']','','=arr_derefload') -> loading from array element of class
	lw $regfree1, 0($sp)
	lw $regfree2, p1_exp_offset($sp)
	li $regfree3, width
	mult $regfree2, $regfree3
	mflo $regfree2
	addi $regfree2, $regfree2, p1_offset
	addi $regfree1, $regfree1, $regfree2
	lw $regfree3, ($regfree2)
	sw $regfree3, p0_offset($sp)

29.) TAC.emit(p[0]['place'],p[1]['var']['place']+'['+p[1]['exp']['place']+']','','=arr') -> register = array_element
	lw $regfree1, p1_exp_offset($sp)
	li $regfree2, width
	mult $regfree1, $regfree2
	mflo $regfree1
	addi $regfree1, $regfree1, $p1_offset
	add $regfree2, $sp, $regfree1
	lw $regfree3, ($regfree2)
	sw $regfree3, p0_offset($sp)

30.) temporary = obj_member

31.) classType_temporary(p[0]) allocated(p[3]) width(p[2])

32.) param register(p[0])
        - move a_i register

33.) param @self ??

34.) jump to label(p[2])
        - jal label

35.) jump_back
        - jr $31
36.) getreturn register(p[0])
        - move register,$v0

37.) register assign_ops register
        - add register0,register0,register1
        - sub register0,register0,register1
        - mult register0,register1
        - mflo register0
        - div register0,register1
        - mflo register0
        - div register0, register1
        - mfhi register0
        - xor register0,register0,register1
        - or register0,register0,register1
        - and register0,register0,register1
        - srlv register0,register0,register1
        - sllv register0,register0,register1

38.) register assign_derefstore register ??

39.) temporary assign_object object_member
    object_member assign_object temporary

40.) temporary assign_arrayElement array_element
        - lw $t, i($s)
     array_element assign_arrayElement temporary
     
     array_element arr+_derefstore register ??
     
     temporary_register arr+_derefstore array_element ?? 

41.) label name

42.) print (char/int/double/bool)register
        - int/bool:
        li $v0,1
        move $a0,register
        syscall
        - double:
        li $v0,3
        move $a0,register
        syscall
        - char:
        li $v0,11
        move $a0,read
        syscall

43.) read address, width
        - int:
        li $v0,5
        syscall
        sw $v0,address

        - double:
        li $v0,7
        syscall
        sw $v0,address

        - char:
        li $v0,12
        syscall
        move $address,$v0

        - stringL
        li $v0,0
        la $a0,address
        li $a1,width
        syscall
        
44.) read_deref address,width
    
45.) new_identifier assign register(simple-type)
        - lw t, register //TODO
46.) setreturn register/void
        - move $v0,register


