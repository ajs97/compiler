1.) exit
	li $v0, 10
	syscall

2.) jumplabel main_class_Main()
	#This has to be done at the end and separately from other jumplabels.

3.) TAC.emit(p0['place'], p1['place'],'', '=') -> register1 = register2
	lw $regfree1, p1_offset($sp)          
	move $regfree2, $regfree1
	sw $regfree2, p0_offset($sp)

3.1) TAC.emit(p0['place'],0,'', '=') -> register1 = register2
	li $regfree1, 0          
	sw $regfree1, p0_offset($sp)

3.2) TAC.emit(p0['place'],1,'', '=') -> register1 = register2
	li $regfree1, 1          
	sw $regfree1, p0_offset($sp)

4.) TAC.emit(p1['place'],0,lineno,'cond_goto')  -> cond_jump(p[3]) to 'line'(p[2]) on register(p[0]) == 0(p[1])
        li $regfree1, 0
	lw $regfree2, p1_offset($sp)
	beq $regfree1,$regfree2,L_lineno

4.1) TAC.emit(p1['place'],1,lineno,'cond_goto')  -> cond_jump(p[3]) to 'line'(p[2]) on register(p[0]) == 0(p[1])
        li $regfree1, 1
	lw $regfree2, p1_offset($sp)
	beq $regfree1,$regfree2,L_lineno

4.2) TAC.emit(p1['place'],p2['place'],lineno,'cond_goto')  -> cond_jump(p[3]) to 'line'(p[2]) on register(p[0]) == 0(p[1])
	lw $regfree1, p1_offset($sp)
	lw $regfree2, p2_offset($sp)
	beq $regfree1,$regfree2,L_lineno


5.) TAC.emit('','',lineno,'goto') -> go_to(p[0]) line(p[2])
        b L_lineno

6.) register = 1/0
	Done in 4.1 and 4.2

7.) TAC.emit(p0['place'], p1['place'], p3['place'], '|') -> register0 = register1 bit_or register2 (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	or $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
	

8.) TAC.emit(p0['place'], p1['place'], p3['place'], '^') -> register = register bit_xor register (only for int)
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	xor $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

9.) TAC.emit(p0['place'], p1['place'], p3['place'], '^') -> register = register bit_and register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	and $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)	
        
10.) TAC.emit(p0['place'], p1['place'], p3['place'], '==') -> register = register equal register
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	seq $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)	        
	
11.) TAC.emit(p0['place'], p1['place'], p3['place'], '!=') -> register = register not_equal register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sne $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)	

12.) TAC.emit(p0['place'], p1['place'], p3['place'], '<') -> register0 = register1 less_than register2
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	slt $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)        
	
13.) TAC.emit(p0['place'], p1['place'], p3['place'], '>') -> register = register greater_than register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sgt $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)      

14.) TAC.emit(p0['place'], p1['place'], p3['place'], '<=') -> register = register less_than_equal register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sle $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

15.) TAC.emit(p0['place'], p1['place'], p3['place'], '>=') -> register = register greater_than_equal register
        lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sge $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

16.) TAC.emit(p0['place'], p1['place'], p3['place'], '<<') ->register = register lshift register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sllv $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
        
17.) TAC.emit(p0['place'], p1['place'], p3['place'], '>>') ->register = register rshift register (only for int)
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	srlv $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)

18.) TAC.emit(p0['place'], p1['place'], p3['place'], '+') ->register = register add register
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	add $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
   
19.) TAC.emit(p0['place'], p1['place'], p3['place'], '-') ->register = register1 sub register2
	lw $regfree1, p1_offset($sp)        
	lw $regfree2, p3_offset($sp)        
	sub $regfree3, $regfree1, $regfree2
	sw $regfree3, p0_offset($sp)
   
20.) register0 = register1 mult register2
        - mult register1,register2
        - mflo register0 

21.) register = register div register
        - div register1,register2
        - mflo register0
    
22.) register = register mod register (only for int)
        - mult register1,register2
        - mfhi register0

23.) register = bit_complement register (int and double)
        - addi temp,-1
        - xor register0,register1,temp

24.) register1 = negative register2 (int and double)
        - neg $register1,$register2

25.) register = bit_not register (only bool)
        - addi temp,1
        - xor register0,register1,temp

26.) new temporary (declare and assign) register
        - lw temporary,register

27.) register =_derefload register ??

28.) register =arr_derefload array_element ??

29.) register = array_element

30.) temporary = obj_member

31.) classType_temporary(p[0]) allocated(p[3]) width(p[2])

32.) param register(p[0])
        - move a_i register

33.) param @self ??

34.) jump to label(p[2])
        - jal label

35.) jump_back
        - jr $31
36.) getreturn register(p[0])
        - move register,$v0

37.) register assign_ops register
        - add register0,register0,register1
        - sub register0,register0,register1
        - mult register0,register1
        - mflo register0
        - div register0,register1
        - mflo register0
        - div register0, register1
        - mfhi register0
        - xor register0,register0,register1
        - or register0,register0,register1
        - and register0,register0,register1
        - srlv register0,register0,register1
        - sllv register0,register0,register1

38.) register assign_derefstore register ??

39.) temporary assign_object object_member
    object_member assign_object temporary

40.) temporary assign_arrayElement array_element
        - lw $t, i($s)
     array_element assign_arrayElement temporary
     
     array_element arr+_derefstore register ??
     
     temporary_register arr+_derefstore array_element ?? 

41.) label name

42.) print (char/int/double/bool)register
        - int/bool:
        li $v0,1
        move $a0,register
        syscall
        - double:
        li $v0,3
        move $a0,register
        syscall
        - char:
        li $v0,11
        move $a0,read
        syscall

43.) read address, width
        - int:
        li $v0,5
        syscall
        sw $v0,address

        - double:
        li $v0,7
        syscall
        sw $v0,address

        - char:
        li $v0,12
        syscall
        move $address,$v0

        - stringL
        li $v0,0
        la $a0,address
        li $a1,width
        syscall
        
44.) read_deref address,width
    
45.) new_identifier assign register(simple-type)
        - lw t, register //TODO
46.) setreturn register/void
        - move $v0,register
